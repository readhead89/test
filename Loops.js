/*
Цикл — это инструмент программирования, который повторяет набор инструкций до тех пор, пока не будет достигнуто заданное условие, называемое условием остановки . Как программист, вы обнаружите, что постоянно полагаетесь на циклы! Вы услышите общий термин iterate при обращении к циклам; iterate просто означает «повторять».
Когда нам нужно повторно использовать задачу в нашем коде, мы часто объединяем это действие в функцию. Точно так же, когда мы видим, что процесс должен повторяться несколько раз подряд, мы пишем цикл. Циклы позволяют нам создавать эффективный код, который автоматизирует процессы для создания масштабируемых и управляемых программ.
Как показано на диаграмме, циклы итерируют или повторяют действие до тех пор, пока не будет выполнено определенное условие. Когда условие выполнено, цикл останавливается, и компьютер переходит к следующей части программы.Цикл — это инструмент программирования, который повторяет набор инструкций до тех пор, пока не будет достигнуто заданное условие, называемое условием остановки . Как программист, вы обнаружите, что постоянно полагаетесь на циклы! Вы услышите общий термин iterate при обращении к циклам; iterate просто означает «повторять».
Когда нам нужно повторно использовать задачу в нашем коде, мы часто объединяем это действие в функцию. Точно так же, когда мы видим, что процесс должен повторяться несколько раз подряд, мы пишем цикл. Циклы позволяют нам создавать эффективный код, который автоматизирует процессы для создания масштабируемых и управляемых программ.
Как показано на диаграмме, циклы итерируют или повторяют действие до тех пор, пока не будет выполнено определенное условие. Когда условие выполнено, цикл останавливается, и компьютер переходит к следующей части программы.
 */

/*
Цикл For
Вместо того, чтобы писать один и тот же код снова и снова, циклы позволяют нам сказать компьютерам, чтобы они повторяли заданный блок кода самостоятельно. Один из способов дать компьютерам эти инструкции — использовать for цикл .
Типичный for цикл включает в себя переменную итератора , которая обычно появляется во всех трех выражениях. Переменная итератора инициализируется, проверяется на соответствие условию остановки и присваивается новое значение на каждой итерации цикла. Переменные итератора могут иметь любое имя, но лучше всего использовать описательное имя переменной. Цикл for содержит три выражения, разделенные ;скобками:
инициализация запускает цикл и может также использоваться для объявления переменной итератора .
условие остановки — это условие, по которому оценивается переменная итератора: если условие соответствует результату, trueблок кода будет запущен, а если он соответствует — false код остановится.
оператор итерации используется для обновления переменной итератора в каждом цикле.
Синтаксис цикла for выглядит следующим образом:
for (let counter = 0; counter < 4; counter++) {
  console.log(counter);
}
В этом примере вывод будет следующим:
0
1
2
3
Разберем пример:
Инициализация let counter = 0, поэтому цикл начнет отсчет с 0.
Условие остановки counter < 4означает, что цикл будет выполняться до тех пор, пока переменная итератора counter меньше 4.
Оператор итерации counter++. Это означает, что после каждого цикла значение counter будет увеличиваться на 1. Для первой итерации counter будет равно 0, для второй итерации counter будет равно 1 и так далее.
Блок кода, заключенный в фигурные скобки, console.log(counter)будет выполняться до тех пор, пока условие не будет оценено как false. Условие будет ложным, если counter оно больше или равно 4 — момент, когда условие становится ложным, иногда называют условием остановки .
Этот for цикл позволяет писать 0, 1, 2и 3программно.
 */
for (let a = 5;a<=10;a++){
    console.log(a)
}

for (let counter = 3; counter >= 0; counter--){
    console.log(counter);
}

//Перебор массиво с помощью цикла
/*Перебор массивов
for циклы очень удобны для перебора структур данных. Например, мы можем использовать for цикл для выполнения одной и той же операции над каждым элементом массива. Массивы содержат списки данных, таких как имена клиентов или информация о продукте. Представьте, что у нас есть магазин, и мы хотим повысить цену на каждый товар в нашем каталоге. Это может быть много повторяющегося кода, но с помощью цикла for для итерации по массиву мы легко справимся с этой задачей Чтобы перебрать каждый элемент массива, for цикл должен использовать свойство массива .length в его условии.
 Посмотрите пример ниже, чтобы увидеть, как for циклы повторяются в массивах:
const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
for (let i = 0; i < animals.length; i++){
  console.log(animals[i]);
}
Этот пример даст вам следующий вывод:
Grizzly Bear
Sloth
Sea Lion
В приведенном выше цикле мы назвали нашу переменную итератора i. Это соглашение об именах переменных, которое вы увидите во многих циклах. Когда мы используем i для перебора массивов, мы можем думать об этом как о сокращении слова индекс . Обратите внимание, как наше условие остановки проверяет, что i меньше чем animals.length. Помните, что массивы имеют нулевой индекс, индекс последнего элемента массива эквивалентен длине этого массива минус 1. Если мы попытаемся получить доступ к элементу по индексу, мы зайдем слишком animals.length далеко!
С for циклами нам проще работать с элементами в массивах.
 */

 /*
 Напишите for цикл, который перебирает наш vacationSpot массив, используя iв качестве переменной итератора.
Внутри блока цикла for используйте console.log()для регистрации каждого элемента в vacationSpots массиве после строки 'I would love to visit '. Например, первый раунд цикла должен выводиться 'I would love to visit Bali'  на консоль.
  */
const vacationSpots = ['Bali', 'Paris', 'Tulum'];
for (let i=0; i< vacationSpots.length; i++){
    console.log('I would love to visit '+vacationSpots[i])
}

/*
Вложенные циклы
Когда у нас есть цикл, работающий внутри другого цикла, мы называем это вложенным циклом . Одно из применений вложенного for цикла — сравнение элементов двух массивов. Для каждого раунда внешнего for цикла внутренний for цикл будет выполняться полностью.
Рассмотрим пример вложенного for цикла:
const myArray = [6, 19, 20];
const yourArray = [19, 81, 2];
for (let i = 0; i < myArray.length; i++) {
  for (let j = 0; j < yourArray.length; j++) {
    if (myArray[i] === yourArray[j]) {
      console.log('Both arrays have the number: ' + yourArray[j]);
    }
  }
}
Давайте подумаем, что происходит во вложенном цикле в нашем примере. Для каждого элемента внешнего массива циклов myArray внутренний цикл будет выполняться полностью, сравнивая текущий элемент внешнего массива myArray[i]с каждым элементом внутреннего массива yourArray[j]. Когда он находит совпадение, он выводит строку на консоль.
Теперь ваша очередь написать вложенный цикл!
Примечание. Чтобы выйти из бесконечного цикла в упражнении, обновите страницу , а затем исправьте код для вашего цикла(ов).
 */

/*
Представьте, что вы крупный программист для платформы социальных сетей! Вам было поручено создать прототип программы взаимных подписчиков. Вам понадобятся два массива «друзей» от двух фиктивных пользователей, чтобы вы могли извлечь имена подписчиков, которые существуют в обоих списках. Создайте переменную с именем bobsFollowers и установите ее равной массиву с четырьмя строками, представляющими имена друзей Боба.
 */

//Цикл While
/*
Ты отлично справляешься! Мы собираемся научить вас другому типу цикла: whileциклу . Для начала преобразуем forцикл в whileцикл:
// A for loop that prints 1, 2, and 3
for (let counterOne = 1; counterOne < 4; counterOne++){
  console.log(counterOne);
}
// A while loop that prints 1, 2, and 3
let counterTwo = 1;
while (counterTwo < 4) {
  console.log(counterTwo);
  counterTwo++;
}
Давайте разберем, что происходит с нашим while синтаксисом цикла:
Переменная counterTwo объявляется перед циклом. Мы можем получить к нему доступ внутри нашего while цикла, поскольку он находится в глобальной области видимости.
Мы начинаем наш цикл с ключевого слова, while за которым следует условие остановки или условие проверки . Это будет оцениваться перед каждым раундом цикла. Пока условие оценивается как true, блок будет продолжать работать. Как только он оценит false цикл, он остановится.
Далее у нас есть блок кода нашего цикла, который выводит counterTwo на консоль и увеличивает counterTwo.
Что бы произошло, если бы мы не увеличивали counterTwo внутри нашего блока? Если бы мы не включили это, counterTwo всегда было бы его начальное значение, 1. Это означало бы, что условие тестирования counterTwo < 4всегда будет оцениваться как , true и наш цикл никогда не остановится! Помните, что это называется бесконечным циклом , и мы всегда хотим избежать этого . Бесконечные циклы могут занять всю вычислительную мощность вашего компьютера, что может привести к зависанию вашего компьютера.
Так что вам может быть интересно, когда использовать while цикл! Синтаксис цикла while идеален, когда мы заранее не знаем, сколько раз цикл должен выполняться. Думайте о еде как о while цикле: когда вы начинаете откусывать, вы не знаете точное количество, которое вам нужно, чтобы насытиться. Скорее ты будешь есть, while ты голоден. В ситуациях, когда мы хотим, чтобы цикл выполнялся неопределенное количество раз, while циклы — лучший выбор.
 */
/*
Под cards массивом объявите переменную currentCard с let ключевым словом, но не присваивайте ей значение.
Создайте while цикл с условием, которое проверяет, currentCard не имеет ли это значение 'spade'.
Внутри блока вашего while цикла добавьте следующую строку кода:
currentCard = cards[Math.floor(Math.random() * 4)];
Math.floor(Math.random() * 4)даст нам случайное число от 0до 3. Мы будем использовать это число для индексации cards массива и присвоим значение currentCard случайному элементу из этого массива.
Потрясающий! Ваш цикл работает, но вы не можете сказать, потому что он ничего не выводит. Давайте добавим console.log()оператор в наш whileблок. Внутри блока после того, как вы присвоите currentCard новое значение, войдите currentCard в консоль.
Для удовольствия вы можете запустить свой код несколько раз и посмотреть, как изменится результат!
 */
const cards = ['diamond', 'spade', 'heart', 'club'];
let currentCard
while (currentCard !=='spade'){
    currentCard = cards[Math.floor(Math.random() * 4)];
    console.log (currentCard)
}
// Цикл Do While
/*
В некоторых случаях вы хотите, чтобы фрагмент кода выполнялся хотя бы один раз, а затем зацикливался на определенном условии после его первоначального запуска. Вот тут и do...while приходит заявление.
В do...while заявлении говорится, что нужно выполнить задачу один раз, а затем продолжать выполнять ее до тех пор, пока определенное условие больше не будет выполняться. Синтаксис оператора do...while выглядит следующим образом:
let countString = '';
let i = 0;
do {
  countString = countString + i;
  i++;
} while (i < 5);
console.log(countString);
В этом примере блок кода вносит изменения в переменную, добавляя к ней countString строковую форму переменной . iВо-первых, блок кода после do ключевого слова выполняется один раз. Затем оценивается состояние. Если условие оценивается как true, блок будет выполняться снова. Цикл останавливается, когда условие оценивается как false.
Обратите внимание, что цикл while и do...while отличается! В отличие от while цикла, do...while будет выполняться хотя бы один раз, независимо от того, оценивается ли условие как true.
const firstMessage = 'I will print!';
const secondMessage = 'I will not print!';
// A do while with a stopping condition that evaluates to false
do {
 console.log(firstMessage)
} while (true === false);
// A while loop with a stopping condition that evaluates to false
while (true === false){
  console.log(secondMessage)
};
Примечание. Чтобы выйти из бесконечного цикла в упражнении, обновите страницу , а затем исправьте код для вашего цикла(ов).
 */

/*
Нам нужна программа, моделирующая часть процесса выпечки торта. В зависимости от рецепта требуется разное количество стаканов сахара. Создайте переменную cupsOfSugarNeeded и присвойте ей числовое значение по вашему выбору.
Стаканы сахара нужно добавлять в тесто по одному. Объявите переменную cupsAdded и присвойте ей значение 0.
Мы сладкоежки, поэтому хотим добавить в тесто хотя бы одну чашку сахара, даже если значение cupsOfSugarNeeded равно 0.
Создайте do...while цикл, который увеличивается cupsAdded на единицу, пока cupsAdded меньше cupsOfSugarNeeded.
Чтобы помочь нам визуализировать вывод на каждой итерации цикла, добавьте console.log внутри do...while блока и запишите значение cupsAdded.
 */
let cupsOfSugarNeeded = 5
let cupsAdded = 0
do {
    cupsAdded = cupsAdded + cupsOfSugarNeeded
    cupsAdded ++
}
while (cupsAdded < cupsOfSugarNeeded)
console.log(cupsAdded)

//Break
/*
Представьте, что мы хотим завести собаку. Мы планируем ходить в приют каждый день в течение года, а потом сдадимся. Но что, если мы встретим собаку нашей мечты на 65-й день? Мы не хотим продолжать ходить в приют в течение следующих 300 дней только потому, что наш первоначальный план состоял в том, чтобы отправиться в приют на целый год. В нашем коде, когда мы хотим остановить выполнение цикла, даже если первоначальное условие остановки, которое мы написали для нашего цикла, не было выполнено, мы можем использовать ключевое слово break.
Ключевое break слово позволяет программам «вырваться» из цикла из блока цикла.
Давайте проверим синтаксис ключевого слова break:
for (let i = 0; i < 99; i++) {
  if (i > 2 ) {
     break;
  }
  console.log('Banana.');
}
console.log('Orange you glad I broke out the loop!');
Это вывод для приведенного выше кода:
Banana.
Banana.
Banana.
Orange you glad I broke out the loop!
break операторы могут быть особенно полезны, когда мы перебираем большие структуры данных! С помощью разрывов мы можем добавить условия тестирования помимо условия остановки и выйти из цикла, когда они будут выполнены.
 */

/*

Регистрируйте каждый элемент из rapperArray цикла for с помощью переменной итератора i.
После for цикла выведите строку "And if you don't know, now you know."на консоль. Примечание: поскольку в нашей строке есть символ одинарной кавычки ', мы можем использовать двойные кавычки вокруг строки, чтобы убедиться, что символ печатается.
Добавьте break блок внутри вашего цикла, который вырывается из цикла, если элемент с текущим индексом rapperArray в 'Notorious B.I.G.'. Зарегистрируйте элемент перед выходом из цикла.
 */
const rapperArray = ["Lil' Kim", "Jay-Z", "Notorious B.I.G.", "Tupac"];
for (let i = 0; i < rapperArray.length; i++){
    console.log (rapperArray[i])
    if (rapperArray[i] === "Notorious B.I.G."){
        break
    }
}
console.log ("And if you don't know, now you know.")


