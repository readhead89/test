/*
Блоки и область видимости
Прежде чем мы поговорим о области действия, нам сначала нужно поговорить о блоках .
Мы уже видели блоки, используемые ранее в функциях и if операторах. Блок — это код, находящийся внутри набора фигурных скобок {}. Блоки помогают нам группировать один или несколько операторов вместе и служат важным структурным маркером нашего кода.
Блок кода может быть функцией, например:
const logSkyColor = () => {
  let color = 'blue';
  console.log(color); // blue
}
Обратите внимание, что тело функции на самом деле представляет собой блок кода.
Обратите внимание на блок в if инструкции:
if (dusk) {
  let color = 'pink';
  console.log(color); // pink
}
В следующих нескольких упражнениях мы увидим, как блоки определяют область видимости переменных.
В верхней части файла main.js объявите const переменную с именем city set, равной 'New York City'. Эта переменная будет существовать вне блока.
Под city переменной напишите функцию с именем logCitySkyline.
Внутри тела функции logCitySkyline()напишите другую переменную, используя let named skyscraper, и установите ее равной 'Empire State Building'.
Внутри функции включите оператор return, подобный этому:
return 'The stars over the ' + skyscraper + ' in ' + city;
Под logCitySkyline()функцией используйте console.log()для вывода значения logCitySkyline()на консоль.
Вы заметите, что logCitySkyline()функция без проблем может получить доступ к обеим переменным. В следующем упражнении мы рассмотрим, почему предпочтительнее иметь одну переменную вне блока, а другую внутри блока.
 */

const city = 'New York City';
const logCitySkyline = ()=>{
let skyscraper = 'Empire State Building'
    return `The stars over the ${skyscraper} in ${city}`
}
console.log(logCitySkyline())

/*
Глобальный масштаб
Область видимости — это контекст, в котором объявлены наши переменные. Мы думаем о области действия по отношению к блокам, потому что переменные могут существовать как вне, так и внутри этих блоков.
В глобальной области видимости переменные объявляются вне блоков. Эти переменные называются глобальными переменными . Поскольку глобальные переменные не связаны внутри блока, к ним может обращаться любой код в программе, включая код в блоках.
Давайте посмотрим на пример глобальной области видимости:
const color = 'blue';
const returnSkyColor = () => {
  return color; // blue
};
console.log(returnSkyColor()); // blue
Несмотря на то, что color переменная определена вне блока, к ней можно получить доступ в функциональном блоке, что дает ей глобальную область действия.
В свою очередь, color к ним можно получить доступ внутри returnSkyColor функционального блока.
Давайте поработаем с глобальными переменными, чтобы увидеть, как данные могут быть доступны из любого места в программе.
В верхней части main.js напишите три глобальные переменные:
Назовите первую переменную satellite и установите ее равной 'The Moon'.
Назовите вторую переменную galaxy и установите ее равной 'The Milky Way'.
Назовите третью переменную stars и установите ее равной 'North Star'.
Под переменными, созданными на предыдущем шаге, напишите функцию с именем callMyNightSky. Внутри функции включите оператор return, подобный этому:
return 'Night Sky: ' + satellite + ', ' + stars + ', and ' + galaxy;
Под callMyNightSky()функцией используйте console.log()для вывода значения callMyNightSky()на консоль.
Вы заметите, что функциональный блок for callMyNightSky()имеет свободный доступ к глобальным переменным, поскольку переменные доступны для всех строк кода в файле.
 */
const satellite = 'The Moon';
const galaxy = 'The Milky Way';
const stars = 'North Star';
const callMyNightSky =()=>{
    return `Night Sky: ${satellite}, ${stars}, and ${galaxy};`
}
console.log(callMyNightSky())

/*
Область блока
Следующий контекст, который мы рассмотрим, — область действия блока . Когда переменная определена внутри блока, она доступна только для кода внутри фигурных скобок {}. Мы говорим, что переменная имеет область действия блока , потому что она доступна только для строк кода внутри этого блока.
Переменные, объявленные с областью действия блока, называются локальными переменными , поскольку они доступны только для кода, являющегося частью того же блока.
Область действия блока работает следующим образом:
const logSkyColor = () => {
  let color = 'blue';
  console.log(color); // Prints "blue"
};
logSkyColor(); // Prints "blue"
console.log(color); // throws a ReferenceError
Вы заметите:
Определяем функцию logSkyColor().
Внутри функции color переменная доступна только внутри фигурных скобок функции.
Если мы попытаемся зарегистрировать ту же переменную вне функции, она выдаст ошибку ReferenceError.
В main.js определите функцию logVisibleLightWaves().
Внутри logVisibleLightWaves()функции с помощью const создайте переменную lightWaves и установите ее равной 'Moonlight'.
Внутри logVisibleLightWaves()функции под lightWaves переменной добавьте console.log()оператор, который будет регистрировать значение переменной lightWaves при выполнении функции.
Вызов logVisibleLightWaves()функции извне функции.
Под вызовом функции запишите значение lightWaves в консоль вне функции.
Вы заметите, что он регистрирует a ReferenceError, так как переменная привязана к области блока функции!
 */
const logVisibleLightWaves = () => {
    const lightWaves = 'MoonLight'
    console.log(lightWaves)
}
logVisibleLightWaves()
console.log(lightWaves)

/*
Сфера загрязнения
Может показаться хорошей идеей всегда делать ваши переменные доступными, но слишком большое количество глобальных переменных может вызвать проблемы в программе.
Когда вы объявляете глобальные переменные, они помещаются в глобальное пространство имен . Глобальное пространство имен позволяет переменным быть доступными из любой точки программы. Эти переменные остаются там до тех пор, пока программа не завершится, что означает, что наше глобальное пространство имен может очень быстро заполниться.
Загрязнение области — это когда у нас слишком много глобальных переменных, существующих в глобальном пространстве имен, или когда мы повторно используем переменные в разных областях. Загрязнение масштаба затрудняет отслеживание наших различных переменных и настраивает нас на потенциальные несчастные случаи. Например, переменные с глобальной областью действия могут конфликтовать с другими переменными с более локальной областью действия, вызывая неожиданное поведение в нашем коде.
Давайте рассмотрим пример загрязнения области видимости на практике, чтобы мы знали, как этого избежать:
let num = 50;
const logNum = () => {
  num = 100; // Take note of this line of code
  console.log(num);
};
logNum(); // Prints 100
console.log(num); // Prints 100
Вы заметите:
У нас есть переменная num.
Внутри тела функции logNum()мы хотим объявить новую переменную, но забыли использовать let ключевое слово.
Когда мы вызываем logNum(), num переназначается на 100.
Переназначение внутри logNum()влияет на глобальную переменную num.
Несмотря на то, что переназначение разрешено и мы не получим ошибку, если мы решим использовать num позже, мы неосознанно используем новое значение num.
Хотя важно знать, что такое глобальная область, рекомендуется не определять переменные в глобальной области.
Давайте посмотрим, что произойдет, если мы создадим переменную, которая перезапишет глобальную переменную.
Внутри callMyNightSky()функции, в самой первой строке тела функции, назначьте переменную stars как 'Sirius' таковую:
stars = 'Sirius';
Вне функции, под текущим console.log()оператором, добавьте еще один console.log()оператор для входа stars в консоль.
Вы заметите, что глобальная переменная stars была переназначена на 'Sirius'. Другими словами, мы изменили значение глобальной stars переменной, но не так просто прочитать, что именно произошло. Это плохая практика в отношении удобства сопровождения кода, и она может повлиять на нашу программу непредвиденным образом.
 */
const satellite1 = 'The Moon';
const galaxy1 = 'The Milky Way';
let stars1 = 'North Star';
const callMyNightSky1 = () => {
    stars1 = 'Sirius'
    return 'Night Sky: ' + satellite + ', ' + stars + ', ' + galaxy;
};
console.log(callMyNightSky1());
console.log(stars)

/*
Практикуйте хороший обзор
Учитывая проблемы, связанные с глобальными переменными и загрязнением области видимости, мы должны следовать передовым методам для максимально узкой области видимости наших переменных, используя блочную область видимости.
Тщательное определение ваших переменных значительно улучшит ваш код несколькими способами:
Это сделает ваш код более разборчивым, поскольку блоки будут организовывать ваш код в отдельные разделы.
Это делает ваш код более понятным, поскольку разъясняет, какие переменные связаны с различными частями программы, вместо того, чтобы отслеживать их строка за строкой!
Ваш код легче поддерживать, так как он будет модульным.
Это сэкономит память в вашем коде, потому что она перестанет существовать после завершения работы блока.
Вот еще один пример того, как работает область действия блока, определенная внутри if блока:
const logSkyColor = () => {
  const dusk = true;
  let color = 'blue';
  if (dusk) {
    let color = 'pink';
    console.log(color); // Prints "pink"
  }
  console.log(color); // Prints "blue"
};
console.log(color); // throws a ReferenceError
Здесь вы заметите:
Мы создаем переменную color внутри logSkyColor()функции.
После if оператора мы определяем новый блок кода с {}фигурными скобками. Здесь мы присваиваем новое значение переменной, color если if утверждение верно.
Внутри if блока color переменная содержит значение 'pink', хотя вне if блока, в теле функции, color переменная содержит значение 'blue'.
В последней строке мы пытаемся напечатать значение color вне как if оператора, так и определения logSkyColor(). Это вызовет исключение, ReferenceError поскольку color существует только в пределах этих двух блоков — оно никогда не определяется в глобальной области.
Хотя мы используем блочную область видимости, мы по-прежнему загрязняем наше пространство имен, повторно используя одно и то же имя переменной дважды. Лучшей практикой было бы переименовать переменную внутри блока.
Область видимости блока — это мощный инструмент в JavaScript, поскольку он позволяет нам точно определять переменные и не загрязнять глобальное пространство имен. Если переменная не должна существовать вне блока — она не должна!
Внутри тела функции logVisibleLightWaves(), под region переменной и перед предоставленным console.log()оператором, создайте if оператор, который проверяет, является region ли 'The Arctic'.
Внутри if блока определите новую let переменную lightWaves и установите ее равной 'Northern Lights'.
Под переменной в if блоке используйте console.log()для регистрации значения переменной блока внутри if блока.
Запустите свой код и обратите внимание на результат. Внутри if блока console.log(lightWaves)значение выводится Northern Lights на консоль. Вне блока if, но все еще внутри функции, тот же оператор выводится Moonlight на консоль.
 */
const logVisibleLightWaves1 = () => {
    let lightWaves = 'Moonlight';
    let region = 'The Arctic';
return region === 'The Arctic'
    console.log(lightWaves);
};

logVisibleLightWaves1();