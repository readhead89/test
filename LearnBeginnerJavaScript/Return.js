/*
При вызове функции компьютер прогоняет код функции и оценивает результат вызова функции. По умолчанию это результирующее значение undefined.
function rectangleArea(width, height) {
  let area = width * height;
}
console.log(rectangleArea(5, 7)) // Prints undefined
В примере кода мы определили нашу функцию для вычисления параметра area a width и height. Затем rectangleArea()вызывается с аргументами 5и 7. Но когда мы пошли печатать результаты, мы получили undefined. Мы неправильно написали нашу функцию? Нет! На самом деле функция работала нормально, и компьютер вычислил площадь как 35, но мы ее не зафиксировали. Итак, как мы можем это сделать? С ключевым словом return!
использование ключевого слова return в функции
Чтобы вернуть информацию из вызова функции, мы используем оператор return . Чтобы создать оператор возврата, мы используем return ключевое слово, за которым следует значение, которое мы хотим вернуть. Как мы видели выше, если значение опущено, undefined вместо него возвращается значение.
Когда return оператор используется в теле функции, выполнение функции останавливается, а код, следующий за ним, выполняться не будет. Посмотрите на пример ниже:
function rectangleArea(width, height) {
  if (width < 0 || height < 0) {
    return 'You need positive integers to calculate area!';
  }
  return width * height;
}
Если аргумент для width или height меньше 0, то rectangleArea()будет возвращено 'You need positive integers to calculate area!'. Второй оператор return width * height не будет выполняться.
Ключевое return слово является мощным, потому что оно позволяет функциям производить выходные данные. Затем мы можем сохранить вывод в переменную для последующего использования.
Представьте, если бы нам нужно было заказать мониторы для всех в офисе, и этот офис удобно организован в виде сетки. Мы могли бы использовать функцию, которая поможет нам рассчитать необходимое количество мониторов!
Объявите функцию monitorCount()с двумя параметрами. Первый параметр , rows а второй параметр columns.
Давайте вычислим количество мониторов, умножив rows и columns вернув значение.
В теле функции, которую вы только что написали, используйте return ключевое слово для возврата rows * columns.
Теперь, когда функция определена, мы можем вычислить необходимое количество мониторов. Допустим, в офисе 5 рядов и 4 столбца.
Объявите переменную с именем, numOfMonitors используя const ключевое слово, и присвойте numOfMonitors значение вызова monitorCount()с аргументами 5и 4.
Чтобы убедиться, что функция работает правильно, войдите numOfMonitors в консоль.
 */
function monitorCount (rows,columns)  {
return rows * columns
}
const numOfMonitors = monitorCount(5,4)
console.log(numOfMonitors)

/*
Вспомогательные функции
Мы также можем использовать возвращаемое значение функции внутри другой функции. Эти функции, вызываемые внутри другой функции, часто называют вспомогательными функциями . Поскольку каждая функция выполняет определенную задачу, наш код легче читать и при необходимости отлаживать.
Если бы мы хотели определить функцию, которая переводит температуру из градусов Цельсия в градусы Фаренгейта, мы могли бы написать две функции, например:
function multiplyByNineFifths(number) {
  return number * (9/5);
};
function getFahrenheit(celsius) {
  return multiplyByNineFifths(celsius) + 32;
};
getFahrenheit(15); // Returns 59
В приведенном выше примере:
getFahrenheit()вызывается и 15передается в качестве аргумента.
Блок кода внутри getFahrenheit()вызовов multiplyByNineFifths()и передается 15в качестве аргумента.
multiplyByNineFifths()принимает аргумент 15для number параметра.
Блок кода внутри multiplyByNineFifths()функции умножается 15на (9/5), что оценивается как 27.
27возвращается обратно к вызову функции в getFahrenheit().
getFahrenheit()продолжает выполняться. Он добавляет 32к 27, что оценивается как 59.
Наконец, 59возвращается обратно к вызову функции getFahrenheit(15).
Мы можем использовать функции для разделения небольших фрагментов логики или задач, а затем использовать их, когда нам нужно. Написание вспомогательных функций может помочь разделить большие и сложные задачи на более мелкие и более управляемые задачи.
В предыдущем упражнении мы создали функцию для определения количества мониторов, которое нужно заказать для офиса. Теперь давайте напишем другую функцию, которая использует эту monitorCount функцию для определения цены.
Ниже monitorCountСоздайте объявление функции с именем costOfMonitors, которое имеет два параметра, первый параметр rows и второй параметр columns. Пока оставьте тело функции пустым.
Пришло время добавить код в тело функции costOfMonitors для расчета общей стоимости.
Добавьте return оператор, который возвращает значение вызова, monitorCount(rows, columns)умноженное на 200.
Мы должны сохранить стоимость в переменную.
Объявите переменную с именем, totalCost используя const ключевое слово. Присвоить totalCost значение вызова costOfMonitors()с аргументами 5и 4соответственно.
Чтобы убедиться, что функция работает правильно, войдите totalCost в консоль.
 */
function monitorCount1(rows, columns) {
    return rows * columns;
}
function costOfMonitors (rows, columns){
    return monitorCount1(rows,columns) * 200
}
const totalCost = costOfMonitors(5,4)
console.log(totalCost)

/*
Функциональные выражения
Мы также можем использовать возвращаемое значение функции внутри другой функции. Эти функции, вызываемые внутри другой функции, часто называют функциональным выражением . Поскольку каждая функция выполняет определенную задачу, наш код легче читать и при необходимости отлаживать. function ключевое слово. В функциональном выражении имя функции обычно опускается. Функция без имени называется анонимной функцией . Выражение функции часто хранится в переменной, чтобы ссылаться на нее.
Рассмотрим следующее функциональное выражение:
определение функционального выражения
Чтобы объявить функциональное выражение:
Объявите переменную, чтобы имя переменной было именем или идентификатором вашей функции. С момента выпуска ES6 общепринятой практикой является использование const ключевого слова для объявления переменной.
Назначьте в качестве значения этой переменной анонимную функцию, созданную с помощью function ключевого слова, за которым следует набор скобок с возможными параметрами. Затем набор фигурных скобок, содержащих тело функции.
Чтобы вызвать функциональное выражение, напишите имя переменной, в которой хранится функция, а затем круглые скобки, заключающие любые аргументы, передаваемые в функцию.
variableName(argument1, argument2)
В отличие от объявлений функций, функциональные выражения не поднимаются, поэтому их нельзя вызывать до того, как они будут определены.
Давайте определим новую функцию, используя функциональное выражение.
Допустим, у нас есть растение, которое нужно поливать раз в неделю по средам. Мы могли бы определить функциональное выражение, которое поможет нам проверить день недели и нужно ли поливать растение:
Создайте переменную с именем, plantNeedsWater используя const ключевое слово variable.
Назначьте анонимную функцию, которая принимает параметр day to plantNeedsWater.
Теперь нам нужно добавить код в тело функции plantNeedsWater():
В теле функции добавьте if условие, которое проверяет day === 'Wednesday'.
Если условное выражение истинно, внутри if блока кода используйте return ключевое слово для возврата true.
В нерабочие дни 'Wednesday' должно plantNeedsWater()вернуться false:
Добавьте else заявление после if заявления.
Внутри else инструкции используйте return ключевое слово для возврата false.
Вызовите plantNeedsWater()и передайте в 'Tuesday' качестве аргумента.
Проверим, что plantNeedsWater()вернуло ожидаемое значение.
Войдите plantNeedsWater('Tuesday')в консоль. Если это сработало правильно, вы должны увидеть false вход в консоль.
 */